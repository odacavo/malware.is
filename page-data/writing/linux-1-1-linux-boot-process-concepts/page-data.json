{
    "componentChunkName": "component---src-templates-writing-post-js",
    "path": "/writing/linux-1-1-linux-boot-process-concepts",
    "result": {"data":{"markdownRemark":{"html":"<p>In this study series, I'll be following the <a href=\"https://www.comptia.jp/pdf/comptia-linux-xk0-004-exam-objectives.pdf\">CompTIA XK0-004 Linux+ Exam Objectives</a>. This writeup is under domain <em>1.0 - Hardware and System Configuration</em>.</p>\n<h2>1.1 Explain Linux boot process concepts</h2>\n<h2>Boot loaders</h2>\n<p>In short, a boot loader is, by name, a program that is responsible for booting a computer. Think of a computer in the \"off\" state. The computer's entire OS, applications, and data are stored in <a href=\"https://en.wikipedia.org/wiki/Non-volatile_memory\">non-volatile memory</a> (internal hard drives, SSDs, etc.). Because of this, when a computer is powered on, the operating system is not loaded into the RAM in its initial state.</p>\n<p>It's the boot loader's job to load the operating system kernel into memory and execute it. The boot loader is the first piece of software program that runs when a computer starts up. Most modern boot loaders are two-stage: the first stage will load generic drivers and then call on the second stage (which is different depending on OS), which loads and executes the kernel. In multi-boot environments, the first stage of the boot loader will display a \"Choose your boot partition\" screen, and then execute the selected second-stage boot loader.</p>\n<p>To put it in context: First, the BIOS/UEFI is loaded and enumerates the hardware installed in the computer. Then, the BIOS/UEFI hands-off responsibilities to the boot loader to start the OS.</p>\n<h3>GRUB</h3>\n<p>GNU GRUB (short for <em>GNU <strong>GR</strong>and <strong>U</strong>nified <strong>B</strong>ootloader</em>, commonly referred to as GRUB) is a boot loader package from the <a href=\"https://www.gnu.org/\">GNU Project</a>. GRUB2 has replaced what was formerly known as GRUB, which is now referred to as GRUB Legacy. GRUB is not actively developed any longer.</p>\n<p>The GRUB boot loader is compatible with booting a number of operating systems, such as:</p>\n<ul>\n<li>FreeBSD, NetBSD, OpenBSD, and GNU/Linux</li>\n<li>Proprietary OS such as most current Windows releases and OS/2 are supported via a <em>chain-loading function</em></li>\n</ul>\n<p><em>Chain-loading</em> is a technique that allows one boot loader to call another boot loader as if the system had just booted up. For example, when booting Windows, GRUB would initially load the Windows boot loader to then boot Windows.</p>\n<h3>GRUB2</h3>\n<p>GRUB2 was a completely revamped rewrite of the original GNU GRUB boot loader package to handle more modern OS requirements. GRUB2 has since become the primary boot loader for most major distributions of Linux.</p>\n<p>GRUB2 has a number of advantages over GRUB, including the following:</p>\n<ul>\n<li>Wider range of RAID and LVM storage compatibility</li>\n<li>Support for newer UEFI systems and non-x86 based architectures</li>\n<li>Live boot support, ISO image support</li>\n</ul>\n<h2>Boot options</h2>\n<h3>UEFI/EFI</h3>\n<p>UEFI (Unified Extensible Firmware Interface) is a newer replacement for the BIOS (Basic Input/Output System) system found on most existing PCs. Essentially, it is a basic piece of software held in a ROM (Read-only Memory) chip on the motherboard that interacts with the computer's hardware and operating system(s).</p>\n<p>Both UEFI and BIOS are similar, although UEFI is much newer and supports newer technology like faster performance, graphical user interfaces and improved security features.</p>\n<p><img src=\"/images/writing/linux-1-1-linux-boot-process-concepts/bios-uefi.jpg\" alt=\"BIOS and UEFI screens\">\r\n<span class='postImageCaption'><strong>Left:</strong> Traditional BIOS, <strong>Right:</strong> UEFI - <em>Image obtained from <a href=\"https://www.howtogeek.com/56958/htg-explains-how-uefi-will-replace-the-bios/\">How-To Geek</a></em></span></p>\n<p>Later versions of UEFI support Secure Boot. As the name suggests, this is a security feature in which the UEFI will prevent a computer from booting an OS unless it matches a specific signature. This is done to prevent malware from being loaded during the boot process.</p>\n<p>BIOS, despite being old (late 1970s), it is very compatible. Most operating systems will boot from BIOS, while the UEFI standard is maintained by Microsoft; Secure Boot, by design, is subject to Microsoft's approved signatures, and is therefore more proprietary. Secure Boot, however, can typically be turned off.</p>\n<h3>PXE</h3>\n<p>PXE (pronounced \"pixie\"), or <em>Preboot Execution Environment</em> is an industry standard created by Intel to provide pre-boot options within a device's firmware. PXE booting enables certain features, like the ability to load an operating system over a network connection to quickly install an OS across a network to servers and clients.</p>\n<p>In order to work, PXE requires negotiations between client and server, as well as support of several standards. The client must support PXE in the UEFI/BIOS or NIC (Network Interface Card) firmware. The network must have <code>DHCP</code> (Dynamic Host Configuration Protocol) configured to provide network configurations, as well as a <code>TFTP</code> (Trivial File Transfer Protocol) server. Generally, there is also another imaging server hosting specific OS images.</p>\n<p>The PXE boot process works as follows:</p>\n<ol>\n<li>The client BIOS/UEFI initiates a PXE boot.</li>\n<li>The client broadcasts a <code>DHCP</code> request and a PXE request to the server.</li>\n<li>The DHCP server responds with the DHCP response so the client can set up its IP configurations. The server also responds with the IP address of the TFTP server and the filename of the NBP (Network Bootstrap Program). The NBP is a small OS that contains a basic kernel, drivers, and basic programs in order to download the remaining OS components.</li>\n<li>The client downloads and boots the NBP, which then downloads the remaining OS components.</li>\n</ol>\n<h3>NFS</h3>\n<p>NFS (Network File Sharing) is a protocol that allows for the sharing of directories and files between clients over a network. Shared directories can be created on a file server that runs a NFS server component. Users can add files to a shared directory, which are then shared to other users who have access to that directory. An NFS file share is typically mounted on a client machine, presenting similarly to a folder created locally, and can be useful on clients where disk space is limited.</p>\n<p>By modern standards, Network File Sharing is not the most robust option for security as it lacks granular access controls, though NFS is widely used in UNIX environments.</p>\n<h3>Boot from ISO</h3>\n<p>An ISO image, or \"optical disc image\" is a disk image using a file system that would typically be written to an optical disc. ISO images have a variety of uses such as emulating CD images, virtual CD-ROMs, or for burning disk images of operating systems to physical installation media. When an ISO image file of an operating system is obtained or created, it can be used to boot computers using ISO media. The ISO media can be used for booting/installing an OS in the following ways:</p>\n<ol>\n<li>Booting via USB drive</li>\n<li>Booting via CD/DVD drive</li>\n<li>Booting Virtual machines</li>\n</ol>\n<p>If you've ever used a hypervisor (VirtualBox, Hyper-V, etc.) to create a virtual machine, you would have typically mounted an ISO image file of the operating system to the virtual optical drive of the virtual machine. The Linux distro <em>Ubuntu</em>, for example, offers various versions of Ubuntu's ISO image on their <a href=\"https://ubuntu.com/download/desktop\">downloads page</a>.</p>\n<h3>Boot from HTTP/FTP</h3>\n<p>As discussed previously, PXE booting enables the ability to load an operating system over a network connection to install an OS across a network to servers and clients. PXE is a great solution for booting a diskless computer and is often used for terminal stations, thin-clients, and OS mass installations.</p>\n<h2>File locations</h2>\n<h3>/etc/default/grub</h3>\n<p>As previously mentioned, GRUB/GRUB2 is the GNU boot loader used with many Linux distros. In Linux systems, everything is essentially treated as a file. The settings to configure GRUB2 are stored in the <code>/etc/default/grub</code> file and can be edited to change various configurations within the boot loader.</p>\n<p><img src=\"/images/writing/linux-1-1-linux-boot-process-concepts/etc-default-grub.jpg\" alt=\"GRUB Configuration File\">\r\n<span class='postImageCaption'>The <code>/etc/default/grub</code> file opened in gedit - <em>Image obtained from <a href=\"https://www.howtogeek.com/196655/how-to-configure-the-grub2-boot-loaders-settings/\">How-To Geek</a></em></span></p>\n<p>As seen in the above configuration file, certain variables can be changed to affect the behaviour of the boot loader. For example:</p>\n<ul>\n<li><code>GRUB_DEFAULT=</code> - Choose the Default OS</li>\n<li><code>GRUB_HIDDEN_TIMEOUT=</code> - Choose whether GRUB is hidden (0) and automatically boot to the default OS instead of showing the GRUB menu</li>\n<li><code>GRUB_TIMEOUT=</code> - Control GRUB's menu timeout (if it is not automatically hidden with the above configuration)</li>\n<li><code>GRUB_BACKGROUND=</code> - Controls whether a background image file is used. By default, it is white text on a black background</li>\n</ul>\n<p>Once changes have been saved to this file (always remember to back it up before making any changes), run the <code>sudo update-grub</code> command. Your changes will become part of the <code>grub.cfg</code> file and will be used each time you boot your computer. GRUB2 menu-configuration settings are taken from <code>/etc/default/grub</code> when generating <code>grub.cfg</code>.</p>\n<p>Configuration of the Legacy GRUB boot loader was fairly simple and straightforward. You would just modify <code>/boot/grub/grub.conf</code> to make customizations. With GRUB2, you can modify <code>/boot/grub2/grub.cfg</code>, but it is a much more complex file and the <code>grub.cfg</code> changes may be overwritten when a new kernel is installed. In the case of GRUB2, you would make these changes in the above <code>/etc/default/grub</code> file.</p>\n<h3>/etc/grub2.cfg</h3>\n<p>The file name <code>/etc/grub2.cfg</code> is a symbolic link to the <code>grub.cfg</code> file, whose location is architecture dependent but typically located in <code>/boot/grub2/grub.cfg</code>.</p>\n<h3>/boot</h3>\n<p>As the location suggests, the <code>/boot</code> directory holds files used in booting the operating system.</p>\n<h3>/boot/grub</h3>\n<p>The <code>/boot/grub</code> directory contains the GRUB modules and menu file (<code>grub.cfg</code>) if using the Legacy GRUB boot loader.</p>\n<h3>/boot/grub2</h3>\n<p>The <code>/boot/grub2</code> directory contains the GRUB modules and menu file (<code>grub.cfg</code>) if using the GRUB2 boot loader.</p>\n<h3>/boot/efi</h3>\n<p>The <code>/boot/efi</code> system partition is simply the boot partition created when the system's motherboard runs UEFI rather than BIOS. The mount point for the EFI system partition is usually <code>/boot/efi</code>, where its content is accessible after Linux is booted.</p>\n<h2>Boot modules and files</h2>\n<h3>Commands</h3>\n<ul>\n<li>\n<p><code>mkinitrd</code> is a command used to create an initial image used by the kernel for preloading the block device modules (such as IDE, SCSI or RAID) which are needed to access the root filesystem.</p>\n</li>\n<li>\n<p><code>dracut</code> is used to create a new or backup initialization RAM disk. The init RAM file is what is booted to before the kernel is loaded. Some systems use the <code>dracut</code> package to create an initramfs image.</p>\n</li>\n<li>\n<p><code>grub2-install</code> is a command used to install GRUB onto a device. This includes copying GRUB images into the target directory of the device (generally <code>/boot/grub</code>), and on some platforms may also include installing GRUB onto a boot sector.</p>\n</li>\n<li>\n<p><code>grub2-mkconfig</code> is a command to scan a system's drives for installed bootable operating systems (including Windows, MacOS, and any Linux distributions) and generates a corresponding GRUB2 configuration file.</p>\n</li>\n</ul>\n<h3>initramfs</h3>\n<p><code>initramfs</code> is used as the first root filesystem that your machine has access to. It is used for mounting the rootfs (root filesystem) which contains all of the system's data. The <code>initramfs</code> carries the modules needed for mounting the rootfs.</p>\n<h3>efi files</h3>\n<p>A file with the <code>EFI</code> file extension is an Extensible Firmware Interface file. These are boot loader executable files which live on UEFI-based computer systems, and contain the data and instructions on how the boot process should proceed. The EFI boot loader for Linux will differ depending on the distribution you have installed, but on an Ubuntu system, for example, it would be located in <code>/EFI/ubuntu/elilo.efi</code>.</p>\n<h3>vmlinuz</h3>\n<p><code>vmlinuz</code> is the name of the compressed form of the Linux kernel executable. A kernel is a program that functions as the central core of a computer operating system. It is the first thing that is loaded into memory when a computer is booted up, and it remains in memory for the duration of the system's operation. <code>vmlinuz</code> is located in the <code>/boot</code> directory.</p>\n<h3>vmlinux</h3>\n<p>Not to be confused with \"vmlinuz\", <code>vmlinux</code> is the kernel in a non-compressed and non-bootable form. <code>vmlinux</code> is generally an intermediate step to producing <code>vmlinuz</code>.</p>\n<h2>Kernel panic</h2>\n<p><img src=\"/images/writing/linux-1-1-linux-boot-process-concepts/kernel_panic.jpg\" alt=\"Kernel panic!\" title=\"test title\">\r\n<span class='postImageCaption'>A kernel panic stop screen - <em>Image obtained from <a href=\"https://medium.com/fnplus/kernel-panic-2b9a46156b1c\">Medium</a></em></span></p>\n<p>A kernel panic is a safety measure an operating system takes when it detects an internal failure in which the OS is unable to safely recover from. The term mostly relates to Unix systems - for Microsoft Windows, you can think of the equivalency of the <a href=\"https://en.wikipedia.org/wiki/Blue_screen_of_death\">Blue Screen of Death</a>.</p>\n<p>If a normal program crashes on your PC, you'll likely be able to keep using your computer. The kernel is able to manage the crash appropriately and recover. However, if the kernel itself crashes and can't figure out how to recover, it has no option but to enter a kernel panic and reboot.</p>\n<p>When a kernel panic occurs, the kernel outputs an error message to the console, dumps kernel memory to disk, and either waits for the system to be manually rebooted, or initiates an automatic reboot. The error information is often highly technical, and can be used in a post-mortem analysis to diagnose the root cause of the issue.</p>","frontmatter":{"date":"Jan 20, 2022","title":"Linux+ 1.1 - Linux Boot Process Concepts","tags":["linux+","comptia"],"description":"One of my main 2022 goals is to vastly expand my proficiency with Linux. Join me as I document my learning journey. Today's objective: Linux Boot Process Concepts"},"timeToRead":10}},"pageContext":{"slug":"linux-1-1-linux-boot-process-concepts"}},
    "staticQueryHashes": []}